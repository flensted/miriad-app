#!/bin/bash
# miriad-tunnel - Expose your HTTP services to the internet
#
# This tool lets you make local web servers accessible via public URLs.
# When you run a web server inside your container, use miriad-tunnel to
# create a public URL that anyone can access.

set -e

# =============================================================================
# Configuration
# =============================================================================

TUNNEL_SERVER_URL="${TUNNEL_SERVER_URL:-}"
TUNNEL_HASH="${TUNNEL_HASH:-}"
CAST_AUTH_TOKEN="${CAST_AUTH_TOKEN:-}"
TUNNEL_CONFIG_DIR="${TUNNEL_CONFIG_DIR:-/tmp/tunnel}"

# Derive public domain from TUNNEL_SERVER_URL
# e.g., https://tunnel.staging.cast-stack.site -> staging.cast-stack.site
get_public_domain() {
    local url="$TUNNEL_SERVER_URL"
    local host="${url#https://}"
    host="${host#http://}"
    host="${host%%/*}"
    host="${host%%:*}"
    if [[ "$host" == tunnel.* ]]; then
        echo "${host#tunnel.}"
    else
        echo "$host"
    fi
}

TUNNEL_PUBLIC_DOMAIN="${TUNNEL_PUBLIC_DOMAIN:-$(get_public_domain)}"

# Service name validation: alphanumeric, lowercase, max 20 chars
MAX_SERVICE_NAME_LENGTH=20
MAX_SERVICES=10

# =============================================================================
# Colors and Logging
# =============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info() {
    echo -e "${GREEN}[tunnel]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[tunnel]${NC} $1"
}

log_error() {
    echo -e "${RED}[tunnel]${NC} $1" >&2
}

# =============================================================================
# Service Management
# =============================================================================

# Get path for service-specific files
get_service_dir() {
    local name="$1"
    echo "${TUNNEL_CONFIG_DIR}/services/${name}"
}

# List all mapped services
list_services() {
    local services_dir="${TUNNEL_CONFIG_DIR}/services"
    if [ -d "$services_dir" ]; then
        ls -1 "$services_dir" 2>/dev/null || true
    fi
}

# Count mapped services
count_services() {
    list_services | wc -l | tr -d ' '
}

# Check if a service is running
is_service_running() {
    local name="$1"
    local pid_file="$(get_service_dir "$name")/rathole.pid"
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
        rm -f "$pid_file"
    fi
    return 1
}

# Validate service name
validate_service_name() {
    local name="$1"

    if [ -z "$name" ]; then
        return 0  # Empty is OK (default service)
    fi

    if [ ${#name} -gt $MAX_SERVICE_NAME_LENGTH ]; then
        log_error "Service name too long (max $MAX_SERVICE_NAME_LENGTH chars): $name"
        return 1
    fi

    if ! [[ "$name" =~ ^[a-z0-9]+$ ]]; then
        log_error "Service name must be alphanumeric lowercase: $name"
        return 1
    fi

    return 0
}

# =============================================================================
# Registration API
# =============================================================================

register_service() {
    local local_port="$1"
    local service_name="$2"

    if [ -z "$TUNNEL_SERVER_URL" ]; then
        log_error "TUNNEL_SERVER_URL not set"
        return 1
    fi
    if [ -z "$TUNNEL_HASH" ]; then
        log_error "TUNNEL_HASH not set"
        return 1
    fi
    if [ -z "$CAST_AUTH_TOKEN" ]; then
        log_error "CAST_AUTH_TOKEN not set"
        return 1
    fi

    local base_url
    if [[ "$TUNNEL_SERVER_URL" == https://* ]]; then
        base_url="$TUNNEL_SERVER_URL"
    else
        base_url="https://${TUNNEL_SERVER_URL%%:*}"
    fi

    # Build request body
    local request_body
    if [ -n "$service_name" ]; then
        request_body="{\"tunnelHash\": \"${TUNNEL_HASH}\", \"serviceName\": \"${service_name}\", \"localPort\": ${local_port}}"
    else
        request_body="{\"tunnelHash\": \"${TUNNEL_HASH}\", \"localPort\": ${local_port}}"
    fi

    local response
    response=$(curl -s -w "\n%{http_code}" \
        -X POST "${base_url}/clients/register" \
        -H "Authorization: Container ${CAST_AUTH_TOKEN}" \
        -H "Content-Type: application/json" \
        -d "$request_body" \
        2>&1)

    local http_code
    http_code=$(echo "$response" | tail -n1)
    local body
    body=$(echo "$response" | sed '$d')

    if [ "$http_code" != "200" ] && [ "$http_code" != "201" ]; then
        log_error "Registration failed (HTTP $http_code): $body"
        return 1
    fi

    echo "$body"
}

unregister_service() {
    local service_name="$1"
    local service_id

    # Build full service ID: {serviceName}-{hash} for named, {hash} for default
    if [ -n "$service_name" ]; then
        service_id="${service_name}-${TUNNEL_HASH}"
    else
        service_id="${TUNNEL_HASH}"
    fi

    if [ -z "$TUNNEL_SERVER_URL" ] || [ -z "$CAST_AUTH_TOKEN" ]; then
        return 0  # Skip if not configured
    fi

    local base_url
    if [[ "$TUNNEL_SERVER_URL" == https://* ]]; then
        base_url="$TUNNEL_SERVER_URL"
    else
        base_url="https://${TUNNEL_SERVER_URL%%:*}"
    fi

    # Best effort - don't fail if server unreachable
    curl -s -X DELETE "${base_url}/clients/${service_id}" \
        -H "Authorization: Container ${CAST_AUTH_TOKEN}" \
        >/dev/null 2>&1 || true
}

# =============================================================================
# Commands
# =============================================================================

cmd_map() {
    local local_port="$1"
    local service_name="$2"

    # Validate port
    if [ -z "$local_port" ]; then
        log_error "Usage: miriad-tunnel map <port> [service-name]"
        return 1
    fi

    if ! [[ "$local_port" =~ ^[0-9]+$ ]] || [ "$local_port" -lt 1 ] || [ "$local_port" -gt 65535 ]; then
        log_error "Invalid port: $local_port"
        return 1
    fi

    # Validate service name
    validate_service_name "$service_name" || return 1

    # Use hash as service ID if no name given
    local service_id="${service_name:-_default}"
    local service_dir="$(get_service_dir "$service_id")"

    # Check if already mapped
    if is_service_running "$service_id"; then
        log_warn "Service '$service_id' already mapped"
        return 0
    fi

    # Check service limit
    local current_count=$(count_services)
    if [ "$current_count" -ge "$MAX_SERVICES" ]; then
        log_error "Maximum services reached ($MAX_SERVICES). Unmap some first."
        return 1
    fi

    log_info "Mapping localhost:$local_port..."

    # Register with server
    local reg_response
    reg_response=$(register_service "$local_port" "$service_name") || return 1

    # Parse response
    local service_token control_port control_host rathole_service_name
    service_token=$(echo "$reg_response" | jq -r '.serviceToken // empty')
    control_port=$(echo "$reg_response" | jq -r '.controlPort // 2333')
    control_host=$(echo "$reg_response" | jq -r '.controlHost // empty')
    rathole_service_name=$(echo "$reg_response" | jq -r '.serviceName // empty')

    if [ -z "$service_token" ]; then
        log_error "Registration response missing serviceToken"
        return 1
    fi

    # Determine control host
    local server_host
    if [ -n "$control_host" ]; then
        server_host="$control_host"
    else
        server_host=$(echo "$TUNNEL_SERVER_URL" | sed -E 's|^https?://||' | sed -E 's|:[0-9]+$||' | sed -E 's|/.*$||')
    fi

    # Create service directory
    mkdir -p "$service_dir"

    # Save registration info
    echo "$reg_response" > "${service_dir}/registration.json"
    echo "$local_port" > "${service_dir}/local_port"
    echo "$service_name" > "${service_dir}/service_name"

    # Generate rathole config
    cat > "${service_dir}/client.toml" << EOF
# Auto-generated rathole client config
# Service: ${service_name:-default}
# Local port: ${local_port}

[client]
remote_addr = "${server_host}:${control_port}"
heartbeat_timeout = 40
retry_interval = 1

[client.services.${rathole_service_name}]
token = "${service_token}"
local_addr = "127.0.0.1:${local_port}"
EOF

    # Start rathole client
    nohup rathole --client "${service_dir}/client.toml" > "${service_dir}/rathole.log" 2>&1 &
    local pid=$!
    echo "$pid" > "${service_dir}/rathole.pid"

    # Wait and verify
    sleep 2
    if kill -0 "$pid" 2>/dev/null; then
        # Build public URL
        local public_url
        if [ -n "$service_name" ]; then
            public_url="https://${service_name}-${TUNNEL_HASH}.${TUNNEL_PUBLIC_DOMAIN}"
        else
            public_url="https://${TUNNEL_HASH}.${TUNNEL_PUBLIC_DOMAIN}"
        fi

        log_info "Mapped successfully!"
        echo -e "  ${CYAN}localhost:${local_port}${NC} -> ${CYAN}${public_url}${NC}"
    else
        log_error "Failed to start tunnel. Check ${service_dir}/rathole.log"
        rm -rf "$service_dir"
        return 1
    fi
}

cmd_unmap() {
    local service_name="$1"

    if [ -z "$service_name" ]; then
        log_error "Usage: miriad-tunnel unmap <service-name>"
        log_error "Use 'miriad-tunnel unmap-all' to unmap all services"
        return 1
    fi

    local service_id="${service_name}"
    local service_dir="$(get_service_dir "$service_id")"

    if [ ! -d "$service_dir" ]; then
        log_error "Service not found: $service_name"
        return 1
    fi

    log_info "Unmapping '$service_name'..."

    # Stop rathole
    local pid_file="${service_dir}/rathole.pid"
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        kill "$pid" 2>/dev/null || true
    fi

    # Unregister from server
    unregister_service "$service_name"

    # Clean up
    rm -rf "$service_dir"

    log_info "Unmapped '$service_name'"
}

cmd_unmap_all() {
    local services=$(list_services)

    if [ -z "$services" ]; then
        log_info "No services mapped"
        return 0
    fi

    log_info "Unmapping all services..."

    for service_id in $services; do
        local service_dir="$(get_service_dir "$service_id")"

        # Stop rathole
        local pid_file="${service_dir}/rathole.pid"
        if [ -f "$pid_file" ]; then
            local pid=$(cat "$pid_file")
            kill "$pid" 2>/dev/null || true
        fi

        # Get service name for unregister
        local service_name=""
        if [ -f "${service_dir}/service_name" ]; then
            service_name=$(cat "${service_dir}/service_name")
        fi

        unregister_service "$service_name"
        rm -rf "$service_dir"

        log_info "Unmapped '$service_id'"
    done

    log_info "All services unmapped"
}

cmd_status() {
    echo "=== Tunnel Status ==="
    echo ""

    if [ -z "$TUNNEL_HASH" ]; then
        echo "Hash:   (not configured)"
    else
        echo "Hash:   ${TUNNEL_HASH:0:16}..."
    fi
    echo "Server: ${TUNNEL_SERVER_URL:-"(not configured)"}"
    echo ""

    local services=$(list_services)

    if [ -z "$services" ]; then
        echo "Services: (none mapped)"
        echo ""
        echo "Use 'miriad-tunnel map <port> [name]' to expose a service"
    else
        echo "Services:"
        for service_id in $services; do
            local service_dir="$(get_service_dir "$service_id")"
            local local_port=$(cat "${service_dir}/local_port" 2>/dev/null || echo "?")
            local service_name=$(cat "${service_dir}/service_name" 2>/dev/null || echo "")

            # Build public URL
            local public_url
            if [ -n "$service_name" ]; then
                public_url="https://${service_name}-${TUNNEL_HASH}.${TUNNEL_PUBLIC_DOMAIN}"
            else
                public_url="https://${TUNNEL_HASH}.${TUNNEL_PUBLIC_DOMAIN}"
            fi

            local status_icon
            if is_service_running "$service_id"; then
                status_icon="${GREEN}*${NC}"
            else
                status_icon="${RED}o${NC}"
            fi

            local display_name="${service_name:-default}"
            printf "  %b %-12s localhost:%-5s -> %s\n" "$status_icon" "$display_name" "$local_port" "$public_url"
        done
    fi
    echo ""
}

cmd_logs() {
    local service_name="${1:-_default}"
    local service_dir="$(get_service_dir "$service_name")"
    local log_file="${service_dir}/rathole.log"

    if [ -f "$log_file" ]; then
        tail -f "$log_file"
    else
        log_error "No log file for service: $service_name"
        return 1
    fi
}

# Legacy command - backward compatibility
cmd_up() {
    local port="${TUNNEL_LOCAL_PORT:-8080}"
    cmd_map "$port"
}

cmd_down() {
    cmd_unmap_all
}

cmd_help() {
    cat << 'EOF'
miriad-tunnel - Expose your HTTP services to the internet

This tool lets you make local web servers accessible via public URLs.
When you run a web server inside your container, use miriad-tunnel to
create a public URL that anyone can access.

Commands:
  map <port> [name]   Expose a local port as a public URL
                      Example: miriad-tunnel map 8080 web
                      Creates: https://web-{hash}.cast-stack.site

  unmap <name>        Stop exposing a service
  unmap-all           Stop all services

  status              Show your public URLs and connection state
  logs [name]         Tail logs for a service (default: _default)

  up                  Legacy: same as 'map 8080'
  down                Legacy: same as 'unmap-all'

Quick Start:
  1. Start your web server:  python3 -m http.server 8080
  2. Expose it:              miriad-tunnel map 8080
  3. Share the URL shown in the output

Multiple Services:
  miriad-tunnel map 8080 web    # -> https://web-{hash}.cast-stack.site
  miriad-tunnel map 3000 api    # -> https://api-{hash}.cast-stack.site

Service names must be alphanumeric lowercase, max 20 characters.
Maximum 10 services per container.

EOF
}

# =============================================================================
# Main
# =============================================================================

mkdir -p "$TUNNEL_CONFIG_DIR"

case "${1:-}" in
    map)
        cmd_map "$2" "$3"
        ;;
    unmap)
        cmd_unmap "$2"
        ;;
    unmap-all)
        cmd_unmap_all
        ;;
    status)
        cmd_status
        ;;
    logs)
        cmd_logs "$2"
        ;;
    up)
        cmd_up
        ;;
    down)
        cmd_down
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        if [ -n "${1:-}" ]; then
            log_error "Unknown command: $1"
            echo ""
        fi
        cmd_help
        exit 1
        ;;
esac
